# В google colab добавить: !pip install pyTelegramBotAPI
# Чтобы добавить новое слово — нужно его прописать в массиве DEFINITOINS на 12 строчке
# Важно все новые аббривиатуры в коде писать только с маленьких букв
# Пользователь в телеграм может писать и с большой и с маленькой — код всегда приводит к строчным

from telebot import TeleBot, types

bot = TeleBot(token='token', parse_mode='html') # создание бота

DEFINITOINS = {

'!<':	'не меньше принимает значение true, когда правая часть не меньше левой',
'!=': 'не равно или сравнение на неравенство, true мы получим тогда, когда значения будут не равны',
'!>': 'не больше принимает значение true, когда левая часть не больше правой',
'*': 'используется для соответствия нулю (0) или более экземплярам предшествующих ему строк',
'.': 'используется для соответствия любому отдельному символу, за исключением новой строки',
';': 'конец предложения',
'?': 'используется для сопоставления нуля (0) или одного экземпляра предшествующих ему строк',
'[:class:]': 'соответствует классу символов, т.е. [:alpha:] соответствует буквам, [:space:] соответствует пробелам, [:punct:] соответствует знакам препинания и [:upper:] соответствует буквам верхнего класса',
'[[:<:]]': 'соответствует началу слов',
'[[:>:]]': 'соответствует концу слова',
'[^abc]': 'используется для сопоставления любых символов, кроме включенных',
'[0-9]': 'используется для соответствия любой цифре от 0 до 9',
'[abc]': 'используется для соответствия любому из включенных в него символов',
'[a-z]': 'используется для соответствия любой заглавной букве',
'[a-z]': 'используется для соответствия любой строчной букве',
'^': 'используется для начала совпадения',
'|': 'используется для выделения альтернатив',
'+': 'используется для сопоставления одного или нескольких экземпляров предшествующих ему строк',
'<': 'меньше. принимает значение true, когда правый операнд больше левого',
'<=': 'меньше, либо равно принимает значение true, когда правая часть больше, либо равна левой',
'<>': 'не равно или сравнение на неравенство, true мы получим тогда, когда значения будут не равны',
'=': 'сравнение на равенство. если равенство верное, то результат true, если нет – false',
'>': 'больше. если левая часть (левый операнд) больше правой, то результат true',
'>=': 'больше, либо равно принимает значение true, когда правая часть больше, либо равная левой',
'«%»': 'оператор деления по модулю',
'«*»': 'бинарный оператор деления',
'«/»': 'бинарный оператор деления',
'«+»': 'бинарный оператор сложения',
'«–»': 'бинарный оператор вычитания',
'all': 'осуществляет вывод всех значений из таблицы',
'alter': 'добавить, изменить или удалить столбцы',
'alter table': 'изменяет структуру таблицы',
'and': 'представляет собой получение результата при соблюдении двух поставленных условий',
'any': 'осуществляет сравнение текущего задания с дополнительным запросом.',
'any|all': 'используемый для проверки условий подзапроса, используемых в предложениях where или having',
'as': 'позволяет переименовать столбец или таблицу с помощью псевдонима',
'as': 'присвоение временного имени таблице или столбцу',
'avg': 'вычисляет среднее значение',
'avg()': 'возвращает среднее значение числового столбца',
'begin': 'определяем начало транзакции',
'between': 'оператор выбирает значения в заданном диапазоне включительно',
'bulk insert ': 'для загрузки данных из файла в таблицу',
'cd': 'change directory - сменить папку',
'cd..': 'вернуться на уровень выше',
'cd -': 'попасть в директорию, в которой были до этого',
'chmod': '(от англ. change mode) — команда для изменения прав доступа к файлам и каталогам',
'clear': 'очистить данное окно',
'configure': 'конфигурация/настроить',
'cp..': 'скопировать файл',
'ceiling': 'возвращает наименьшее целое число, которое больше или равно текущему значению',
'collate': 'оператор сопоставления',
'commit': 'фиксируем изменения',
'concat': 'объединение строк',
'count': 'вычисляет количество строк и возвращает результирующее значение в столбце',
'create': 'создать таблицы',
'create table': 'оператор создает таблицу',
'curdate/current_date': 'возвращает текущую дату',
'curtime/current_time': 'возвращает текущее время',
'date_add(date, interval)': 'выполняет сложение даты и определенного временного интервала',
'date_sub(date, interval)': 'выполняет вычитание из даты определенного временного интервала',
'datediff(date1, date2)': 'возвращает разницу в днях между двумя датами',
'dayofmonth(date)': 'возвращает день месяца в виде числа',
'dayofweek(date)': 'возвращает день недели в виде числа',
'dayofyear(date)': 'возвращает номер дня в году',
'delete': 'используется для удаления записи из таблицы',
'deny': 'отнимает у пользователя возможность выполнять действия',
'disable trigger': 'отключить триггер',
'distinct': 'отфильтровывает повторяющиеся значения и возвращает строки указанного столбца',
'drop': 'оператор удаления объектов из базы данных',
'enable trigger': 'включить триггер',
'except': 'используемый для возврата всех записей в первом операторе select, которые не найдены во втором операторе select',
'exists': 'применяется тогда, когда нужно обозначить, интересует ли пользователя результат подзапроса',
'floor': 'возвращает наибольшее целое число, которое меньше или равно текущему значению',
'from': 'источник информации, откуда брать данные.',
'full outer join': 'возвращает все строки, соответствующие условиям в любой из таблиц. если в левой таблице есть строки, которым ничего не соответствует в правой, то они все равно отобразятся в результирующих значениях. то же самое распространяется и на строки из правой таблицы без соответствующих значений в левой',
'grant': 'управление доступом к базе данных',
'group by': 'используется с агрегатными функциями (count, max, min, sum, avg) для группировки набора результатов по одному или нескольким столбцам',
'having': 'позволяет сортировать данные, которые собираются через group by',
'hour(time)': 'возвращает час',
'in': 'позволяет указать несколько значений в предложении where',
'inner join': 'возвращает записи, имеющие совпадающее значение в обеих таблицах',
'insert': 'вставляет новые записи',
'insert into': 'используется для вставки новых записей/строк в таблицу',
'intersect	': 'используется для возврата записей, общих для двух операторов select',
'is null': 'позволяет проверить значение поля на null',
'join': 'добавление таблиц.',
'join': 'выбирает записи, соответствующие значениям в двух таблицах',
'last_day(date)': 'возвращает последний день месяца в виде даты',
'left (outer) join': 'возвращает все записи из левой таблицы (таблица1) и соответствующие записи из правой таблицы (таблица2)',
'left join': 'возвращает все строки из левой таблицы и соответствующие им строки из правой таблицы. строки из левой таблицы возвращаются даже при пустых значениях в правой таблице',
'length': 'возвращает количество символов в строке',
'like': 'используся в предложении where для поиска определенного шаблона в столбце',
'limit': 'количество результатов',
'lower': 'переводит символы строки в нижний регистр',
'max': 'вычисляет наибольшее значение',
'merge': 'смесь операторов update и insert',
'min': 'вычисляет наименьшее значение',
'min() and max()': 'возвращает наименьшее/наибольшее значение выбранного столбца',
'minute(time)': 'возвращает минуты',
'month(date)': 'возвращает месяц',
'not': 'аннулирует любые условия',
'or': 'дает результат в том случае, когда значение true есть хотя бы в одном из операндов',
'order by': 'позволяет сортировать результирующий набор данных по одному или нескольким элементам в разделе select',
'power': 'возводит число в указанную степень',
'rand': 'генерирует случайное число с плавающей точкой в диапазоне от 0 до 1',
'readtext': 'чтение текста',
'rename': 'переименовать',
'replace': 'заменяет подстроку в строке',
'revoke': 'отмена выданных привилегий',
'right (outer) join': 'возвращает все записи из правой таблицы (таблица2) и соответствующие записи из левой таблицы (таблица1)',
'right join': 'возвращает все строки из правой таблицы и соответствующие им строки из левой. в отличие от левого соединения, здесь возвращаются все строки из правой таблицы, даже если им ничего не соответствует в левой',
'rollback': 'откатывает все изменения',
'round': 'округляет число',
'second(time)': 'возвращает секунды ',
'select top': 'указание количества записей, возвращаемых из верхней части таблицы',
'select': 'выбор данных из базы данных',
'sqrt': 'возвращает квадратный корень числа',
'substring': 'извлекает подстроку из строки',
'sum': 'вычисляет сумму значений',
'sum()': 'возвращает общую сумму числового столбца',
'time_to_sec(time)': 'возвращает количество секунд с полуночи и др.',
'to_days(date)': 'возвращает количество дней с 0-го дня года',
'trim': 'удаляет пробелы в начале и конце строки',
'truncate': 'обрезает дробное число до указанного количества знаков после запятой',
'union': 'объединение набора результатов двух или более операторов select',
'unique': 'позволяет проверить уникальность каждой строки',
'update': 'обновление записи в таблице',
'update statistics': 'обновить статистику',
'update text': 'обновляет текст',
'upper': 'переводит символы строки в верхний регистр ',
'where': 'используется для фильтрации записей/строк',
'with': 'запрос, который часто используется для извлечения иерархических данных',
'write text': 'запись текста',
'year(date)': 'возвращает год',

    }

# обработчик команды '/start'
@bot.message_handler(commands=['start'])
def start_command_handler(message: types.Message):
    # отправляем ответ на команду '/start'
    bot.send_message(
        chat_id=message.chat.id, # id чата, в который необходимо направить сообщение, # текст сообщения
        text='Я - БОТ. Меня научили давать определения некоторых команд в SQL, GET, Linyx. Напиши название команды по английски, и я постараюсь дать тебе ответ', # текст сообщения
    )

# обработчик всех остальных сообщений
@bot.message_handler()
def message_handler(message: types.Message):
    # пробуем найти ключевую фразу в словаре 
    definition = DEFINITOINS.get(
        message.text.lower(), # приводим текст сообщения к нижнему регистру
    )
    # если фразы нет в словаре, то переменная definition будет иметь значение None
    # проверяем это условие
    if definition is None:
        # если ключевая фраза не была найдена в словаре
        # отправляем ответ
        bot.send_message(
            chat_id=message.chat.id,
            text='К сожалению, это я еще не знаю',
        )
        # выходим из функции
        return

    # если ключевая фраза была найдена, формируем текст сообщения и отправляем его
    # если перед строкой поставить букву f, то в фигурных скобках {} можно использовать переменные :)
    bot.send_message(
        chat_id=message.chat.id,
        text=f'Значение:\n<code>{definition}</code>',
    )

    bot.send_message(
        chat_id=message.chat.id,
        text=f'Продолжим',
    )


# главная функция программы
def main():
    # запускаем нашего бота
    bot.infinity_polling()


if __name__ == '__main__':
    main()
